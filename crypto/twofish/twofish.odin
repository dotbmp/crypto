package twofish

import "../util"

// @ref(zh): https://github.com/golang/crypto/blob/master/twofish/twofish.go

BLOCK_SIZE :: 16;
MDS_POLY   :: 0x169;
RS_POLY    :: 0x14d;

RS := [4][8]byte {
	{0x01, 0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e},
	{0xa4, 0x56, 0x82, 0xf3, 0x1e, 0xc6, 0x68, 0xe5},
	{0x02, 0xa1, 0xfc, 0xc1, 0x47, 0xae, 0x3d, 0x19},
	{0xa4, 0x55, 0x87, 0x5a, 0x58, 0xdb, 0x9e, 0x03},
};

SBOX := [2][256]byte {
	{
		0xa9, 0x67, 0xb3, 0xe8, 0x04, 0xfd, 0xa3, 0x76, 0x9a, 0x92, 0x80, 0x78, 0xe4, 0xdd, 0xd1, 0x38,
		0x0d, 0xc6, 0x35, 0x98, 0x18, 0xf7, 0xec, 0x6c, 0x43, 0x75, 0x37, 0x26, 0xfa, 0x13, 0x94, 0x48,
		0xf2, 0xd0, 0x8b, 0x30, 0x84, 0x54, 0xdf, 0x23, 0x19, 0x5b, 0x3d, 0x59, 0xf3, 0xae, 0xa2, 0x82,
		0x63, 0x01, 0x83, 0x2e, 0xd9, 0x51, 0x9b, 0x7c, 0xa6, 0xeb, 0xa5, 0xbe, 0x16, 0x0c, 0xe3, 0x61,
		0xc0, 0x8c, 0x3a, 0xf5, 0x73, 0x2c, 0x25, 0x0b, 0xbb, 0x4e, 0x89, 0x6b, 0x53, 0x6a, 0xb4, 0xf1,
		0xe1, 0xe6, 0xbd, 0x45, 0xe2, 0xf4, 0xb6, 0x66, 0xcc, 0x95, 0x03, 0x56, 0xd4, 0x1c, 0x1e, 0xd7,
		0xfb, 0xc3, 0x8e, 0xb5, 0xe9, 0xcf, 0xbf, 0xba, 0xea, 0x77, 0x39, 0xaf, 0x33, 0xc9, 0x62, 0x71,
		0x81, 0x79, 0x09, 0xad, 0x24, 0xcd, 0xf9, 0xd8, 0xe5, 0xc5, 0xb9, 0x4d, 0x44, 0x08, 0x86, 0xe7,
		0xa1, 0x1d, 0xaa, 0xed, 0x06, 0x70, 0xb2, 0xd2, 0x41, 0x7b, 0xa0, 0x11, 0x31, 0xc2, 0x27, 0x90,
		0x20, 0xf6, 0x60, 0xff, 0x96, 0x5c, 0xb1, 0xab, 0x9e, 0x9c, 0x52, 0x1b, 0x5f, 0x93, 0x0a, 0xef,
		0x91, 0x85, 0x49, 0xee, 0x2d, 0x4f, 0x8f, 0x3b, 0x47, 0x87, 0x6d, 0x46, 0xd6, 0x3e, 0x69, 0x64,
		0x2a, 0xce, 0xcb, 0x2f, 0xfc, 0x97, 0x05, 0x7a, 0xac, 0x7f, 0xd5, 0x1a, 0x4b, 0x0e, 0xa7, 0x5a,
		0x28, 0x14, 0x3f, 0x29, 0x88, 0x3c, 0x4c, 0x02, 0xb8, 0xda, 0xb0, 0x17, 0x55, 0x1f, 0x8a, 0x7d,
		0x57, 0xc7, 0x8d, 0x74, 0xb7, 0xc4, 0x9f, 0x72, 0x7e, 0x15, 0x22, 0x12, 0x58, 0x07, 0x99, 0x34,
		0x6e, 0x50, 0xde, 0x68, 0x65, 0xbc, 0xdb, 0xf8, 0xc8, 0xa8, 0x2b, 0x40, 0xdc, 0xfe, 0x32, 0xa4,
		0xca, 0x10, 0x21, 0xf0, 0xd3, 0x5d, 0x0f, 0x00, 0x6f, 0x9d, 0x36, 0x42, 0x4a, 0x5e, 0xc1, 0xe0,
	},
	{
		0x75, 0xf3, 0xc6, 0xf4, 0xdb, 0x7b, 0xfb, 0xc8, 0x4a, 0xd3, 0xe6, 0x6b, 0x45, 0x7d, 0xe8, 0x4b,
		0xd6, 0x32, 0xd8, 0xfd, 0x37, 0x71, 0xf1, 0xe1, 0x30, 0x0f, 0xf8, 0x1b, 0x87, 0xfa, 0x06, 0x3f,
		0x5e, 0xba, 0xae, 0x5b, 0x8a, 0x00, 0xbc, 0x9d, 0x6d, 0xc1, 0xb1, 0x0e, 0x80, 0x5d, 0xd2, 0xd5,
		0xa0, 0x84, 0x07, 0x14, 0xb5, 0x90, 0x2c, 0xa3, 0xb2, 0x73, 0x4c, 0x54, 0x92, 0x74, 0x36, 0x51,
		0x38, 0xb0, 0xbd, 0x5a, 0xfc, 0x60, 0x62, 0x96, 0x6c, 0x42, 0xf7, 0x10, 0x7c, 0x28, 0x27, 0x8c,
		0x13, 0x95, 0x9c, 0xc7, 0x24, 0x46, 0x3b, 0x70, 0xca, 0xe3, 0x85, 0xcb, 0x11, 0xd0, 0x93, 0xb8,
		0xa6, 0x83, 0x20, 0xff, 0x9f, 0x77, 0xc3, 0xcc, 0x03, 0x6f, 0x08, 0xbf, 0x40, 0xe7, 0x2b, 0xe2,
		0x79, 0x0c, 0xaa, 0x82, 0x41, 0x3a, 0xea, 0xb9, 0xe4, 0x9a, 0xa4, 0x97, 0x7e, 0xda, 0x7a, 0x17,
		0x66, 0x94, 0xa1, 0x1d, 0x3d, 0xf0, 0xde, 0xb3, 0x0b, 0x72, 0xa7, 0x1c, 0xef, 0xd1, 0x53, 0x3e,
		0x8f, 0x33, 0x26, 0x5f, 0xec, 0x76, 0x2a, 0x49, 0x81, 0x88, 0xee, 0x21, 0xc4, 0x1a, 0xeb, 0xd9,
		0xc5, 0x39, 0x99, 0xcd, 0xad, 0x31, 0x8b, 0x01, 0x18, 0x23, 0xdd, 0x1f, 0x4e, 0x2d, 0xf9, 0x48,
		0x4f, 0xf2, 0x65, 0x8e, 0x78, 0x5c, 0x58, 0x19, 0x8d, 0xe5, 0x98, 0x57, 0x67, 0x7f, 0x05, 0x64,
		0xaf, 0x63, 0xb6, 0xfe, 0xf5, 0xb7, 0x3c, 0xa5, 0xce, 0xe9, 0x68, 0x44, 0xe0, 0x4d, 0x43, 0x69,
		0x29, 0x2e, 0xac, 0x15, 0x59, 0xa8, 0x0a, 0x9e, 0x6e, 0x47, 0xdf, 0x34, 0x35, 0x6a, 0xcf, 0xdc,
		0x22, 0xc9, 0xc0, 0x9b, 0x89, 0xd4, 0xed, 0xab, 0x12, 0xa2, 0x0d, 0x52, 0xbb, 0x02, 0x2f, 0xa9,
		0xd7, 0x61, 0x1e, 0xb4, 0x50, 0x04, 0xf6, 0xc2, 0x16, 0x25, 0x86, 0x56, 0x55, 0x09, 0xbe, 0x91,
	},
};

Twofish :: struct {
    s: [4][256]u32,
    k: [40]u32,
};

u32_le :: inline proc "contextless"(b: []byte) -> u32 {
	return u32(b[0]) | u32(b[1]) << 8 | u32(b[2]) << 16 | u32(b[3]) << 24;
}

put_u32_le :: inline proc "contextless"(b: []byte, v: u32) {
    b[0] = byte(v);
    b[1] = byte(v >> 8);
    b[2] = byte(v >> 16);
    b[3] = byte(v >> 24);
}

gf_mult :: proc(a, b: byte, p: u32) -> byte {
    a := a;
    B := [2]u32{0, u32(b)};
	P := [2]u32{0, p};
	result: u32;

    for _ in 0..<7 {
        result ~= B[a & 1];
		a >>= 1;
		B[1] = P[B[1] >> 7] ~ (B[1] << 1);
    }
    result ~= B[a & 1];
    return byte(result);
}

mds_column_mult :: proc(input: byte, col: int) -> u32 {
    mul01 := input;
	mul5B := gf_mult(input, 0x5b, MDS_POLY);
	mulEF := gf_mult(input, 0xef, MDS_POLY);

	switch col {
        case 0:
            return u32(mul01) | u32(mul5B) << 8 | u32(mulEF) << 16 | u32(mulEF) << 24;
        case 1:
            return u32(mulEF) | u32(mulEF) << 8 | u32(mul5B) << 16 | u32(mul01) << 24;
        case 2:
            return u32(mul5B) | u32(mulEF) << 8 | u32(mul01) << 16 | u32(mulEF) << 24;
        case 3:
            return u32(mul5B) | u32(mul01) << 8 | u32(mulEF) << 16 | u32(mul5B) << 24;
	}
    return 0;
}

h :: proc(input, key: []byte, offset: int) -> u32 {
    y: [4]byte;
    copy(y[:], input[:]);

    switch(len(key) / 8) {
        case 4:
            y[0] = SBOX[1][y[0]] ~ key[4 * (6 + offset) + 0];
            y[1] = SBOX[0][y[1]] ~ key[4 * (6 + offset) + 1];
            y[2] = SBOX[0][y[2]] ~ key[4 * (6 + offset) + 2];
            y[3] = SBOX[1][y[3]] ~ key[4 * (6 + offset) + 3];
            fallthrough;
        case 3:
            y[0] = SBOX[1][y[0]] ~ key[4 * (4 + offset) + 0];
            y[1] = SBOX[1][y[1]] ~ key[4 * (4 + offset) + 1];
            y[2] = SBOX[0][y[2]] ~ key[4 * (4 + offset) + 2];
            y[3] = SBOX[0][y[3]] ~ key[4 * (4 + offset) + 3];
            fallthrough;
        case 2:
            y[0] = SBOX[1][SBOX[0][SBOX[0][y[0]] ~ key[4 * (2 + offset) + 0]] ~ key[4 * (0 + offset) + 0]];
            y[1] = SBOX[0][SBOX[0][SBOX[1][y[1]] ~ key[4 * (2 + offset) + 1]] ~ key[4 * (0 + offset) + 1]];
            y[2] = SBOX[1][SBOX[1][SBOX[0][y[2]] ~ key[4 * (2 + offset) + 2]] ~ key[4 * (0 + offset) + 2]];
            y[3] = SBOX[0][SBOX[1][SBOX[1][y[3]] ~ key[4 * (2 + offset) + 3]] ~ key[4 * (0 + offset) + 3]];
    }

    mds_mult: u32;
    for v, i in y do mds_mult ~= mds_column_mult(v, int(i));
    return mds_mult;
}

init :: proc(ctx: ^Twofish, key: []byte) {
    key_length := len(key);

    assert(key_length == 16 || key_length == 24 || key_length == 32, "Wrong key length");

    k := key_length / 8;

    S: [BLOCK_SIZE]byte;
    for i in 0..<k {
        for rsRow, j in RS {
            for rsVal, l in rsRow {
                S[4 * i + j] ~= gf_mult(key[8 * i + l], rsVal, RS_POLY);
            }
        }
    }

    tmp: [4]byte;
    for i in 0..<20 {
        for _, j in tmp do tmp[j] = 2 * byte(i);
        A := h(tmp[:], key, 0);
        for _, j in tmp do tmp[j] = 2 * byte(i) + 1;
        B := h(tmp[:], key, 1);
        B = util.ROTL32(B, 8);

        ctx.k[2 * i]     = A + B;
        ctx.k[2 * i + 1] = util.ROTL32(2 * B + A, 9);
    }

    switch k {
        case 2:
            for _, i in ctx.s[0] {
                ctx.s[0][i] = mds_column_mult(SBOX[1][SBOX[0][SBOX[0][byte(i)] ~ S[0]] ~ S[4]], 0);
                ctx.s[1][i] = mds_column_mult(SBOX[0][SBOX[0][SBOX[1][byte(i)] ~ S[1]] ~ S[5]], 1);
                ctx.s[2][i] = mds_column_mult(SBOX[1][SBOX[1][SBOX[0][byte(i)] ~ S[2]] ~ S[6]], 2);
                ctx.s[3][i] = mds_column_mult(SBOX[0][SBOX[1][SBOX[1][byte(i)] ~ S[3]] ~ S[7]], 3);
            }
        case 3:
            for _, i in ctx.s[0] {
                ctx.s[0][i] = mds_column_mult(SBOX[1][SBOX[0][SBOX[0][SBOX[1][byte(i)] ~ S[0]] ~ S[4]] ~ S[8]], 0);
                ctx.s[1][i] = mds_column_mult(SBOX[0][SBOX[0][SBOX[1][SBOX[1][byte(i)] ~ S[1]] ~ S[5]] ~ S[9]], 1);
                ctx.s[2][i] = mds_column_mult(SBOX[1][SBOX[1][SBOX[0][SBOX[0][byte(i)] ~ S[2]] ~ S[6]] ~ S[10]], 2);
                ctx.s[3][i] = mds_column_mult(SBOX[0][SBOX[1][SBOX[1][SBOX[0][byte(i)] ~ S[3]] ~ S[7]] ~ S[11]], 3);
            }
        case:
            for _, i in ctx.s[0] {
                ctx.s[0][i] = mds_column_mult(SBOX[1][SBOX[0][SBOX[0][SBOX[1][SBOX[1][byte(i)] ~ S[0]] ~ S[4]] ~ S[8]]  ~ S[12]], 0);
                ctx.s[1][i] = mds_column_mult(SBOX[0][SBOX[0][SBOX[1][SBOX[1][SBOX[0][byte(i)] ~ S[1]] ~ S[5]] ~ S[9]]  ~ S[13]], 1);
                ctx.s[2][i] = mds_column_mult(SBOX[1][SBOX[1][SBOX[0][SBOX[0][SBOX[0][byte(i)] ~ S[2]] ~ S[6]] ~ S[10]] ~ S[14]], 2);
                ctx.s[3][i] = mds_column_mult(SBOX[0][SBOX[1][SBOX[1][SBOX[0][SBOX[1][byte(i)] ~ S[3]] ~ S[7]] ~ S[11]] ~ S[15]], 3);
            }
    }
}

encrypt :: proc(key, plaintext: []byte) -> [BLOCK_SIZE]byte {
    cipher: [BLOCK_SIZE]byte;
    ctx: Twofish;
    init(&ctx, key);

    S1 := ctx.s[0];
	S2 := ctx.s[1];
	S3 := ctx.s[2];
	S4 := ctx.s[3];

    ia := u32_le(plaintext[0:4]);
	ib := u32_le(plaintext[4:8]);
	ic := u32_le(plaintext[8:12]);
	id := u32_le(plaintext[12:]);

    ia ~= ctx.k[0];
	ib ~= ctx.k[1];
	ic ~= ctx.k[2];
	id ~= ctx.k[3];

    for i in 0..<8 {
        k := ctx.k[8 + i * 4 : 12 + i * 4];
		t2 := S2[byte(ib)] ~ S3[byte(ib >> 8)] ~ S4[byte(ib >> 16)] ~ S1[byte(ib >> 24)];
		t1 := S1[byte(ia)] ~ S2[byte(ia >> 8)] ~ S3[byte(ia >> 16)] ~ S4[byte(ia >> 24)] + t2;
		ic = util.ROTR32(ic ~ (t1 + k[0]), 1);
		id = util.ROTL32(id, 1) ~ (t2 + t1 + k[1]);

		t2 = S2[byte(id)] ~ S3[byte(id >> 8)] ~ S4[byte(id >> 16)] ~ S1[byte(id >> 24)];
		t1 = S1[byte(ic)] ~ S2[byte(ic >> 8)] ~ S3[byte(ic >> 16)] ~ S4[byte(ic >> 24)] + t2;
		ia = util.ROTR32(ia ~ (t1 + k[2]), 1);
		ib = util.ROTL32(ib, 1) ~ (t2 + t1 + k[3]);
    }

    ta := ic ~ ctx.k[4];
	tb := id ~ ctx.k[5];
	tc := ia ~ ctx.k[6];
	td := ib ~ ctx.k[7];

	put_u32_le(cipher[0:4], ta);
	put_u32_le(cipher[4:8], tb);
	put_u32_le(cipher[8:12], tc);
	put_u32_le(cipher[12:], td);

    return cipher;
}

decrypt :: proc(key, ciphertext: []byte) -> [BLOCK_SIZE]byte {
    plaintext: [BLOCK_SIZE]byte;
    ctx: Twofish;
    init(&ctx, key);

    S1 := ctx.s[0];
	S2 := ctx.s[1];
	S3 := ctx.s[2];
	S4 := ctx.s[3];

    ta := u32_le(ciphertext[0:4]);
	tb := u32_le(ciphertext[4:8]);
	tc := u32_le(ciphertext[8:12]);
	td := u32_le(ciphertext[12:]);

    ia := tc ~ ctx.k[6];
	ib := td ~ ctx.k[7];
	ic := ta ~ ctx.k[4];
	id := tb ~ ctx.k[5];

    for i := 8; i > 0; i -= 1 {
		k := ctx.k[4 + i * 4 : 8 + i * 4];
		t2 := S2[byte(id)] ~ S3[byte(id >> 8)] ~ S4[byte(id >> 16)] ~ S1[byte(id >> 24)];
		t1 := S1[byte(ic)] ~ S2[byte(ic >> 8)] ~ S3[byte(ic >> 16)] ~ S4[byte(ic >> 24)] + t2;
		ia = util.ROTL32(ia, 1) ~ (t1 + k[2]);
		ib = util.ROTR32(ib ~ (t2 + t1 + k[3]), 1);

		t2 = S2[byte(ib)] ~ S3[byte(ib >> 8)] ~ S4[byte(ib >> 16)] ~ S1[byte(ib >> 24)];
		t1 = S1[byte(ia)] ~ S2[byte(ia >> 8)] ~ S3[byte(ia >> 16)] ~ S4[byte(ia >> 24)] + t2;
		ic = util.ROTL32(ic, 1) ~ (t1 + k[0]);
		id = util.ROTR32(id ~ (t2 + t1 + k[1]), 1);
	}

    ia ~= ctx.k[0];
	ib ~= ctx.k[1];
	ic ~= ctx.k[2];
	id ~= ctx.k[3];

	put_u32_le(plaintext[0:4], ia);
	put_u32_le(plaintext[4:8], ib);
	put_u32_le(plaintext[8:12], ic);
	put_u32_le(plaintext[12:], id);

    return plaintext;
}